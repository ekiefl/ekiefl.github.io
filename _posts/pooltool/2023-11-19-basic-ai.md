---
layout: post
title: "Making a pool/billiards AI that outperforms humans"
categories: [pooltool]
excerpt: "I code and develop a heuristic-based AI from scratch that outperforms my abilities"
comments: true
series: 7
authors: [evan]
image:
  feature: pooltool/pooltool_banner.png
  display: true
---

{% capture images %}{{site.url}}/images/pooltool/pooltool-basic-ai{% endcapture %}

## Introduction

If you don't know, [pooltool](https://ekiefl.github.io/projects/pooltool/) is an open-source pool physics simulator that I've developed over the last 3 years.

[![pooltoolnow]({{ site.url }}/images/pooltool/pooltool-graphics/gallery_2.png)]({{ site.url }}/images/pooltool/pooltool-graphics/gallery_2.png){:.center-img .width-100}
_**Figure 1**. A screenshot of pooltool._

In this post, I'm going to take you on a journey for developing a 9-ball bot for pooltool. My goal is to create something that outperforms humans and incorporate it into the pooltool ecosystem so users have something to play against. I'm writing this as I go, so we'll see if that's possible!

## Pooltool 101

In this section, I'll incrementally build a script using the pooltool API that runs nine ball games in a loop, where both players take actions autonomously (autonomously, but not intelligently). This will introduce you to the pooltool API and set the stage for creating some hopefully intelligent autonomous players.

### Systems

In order to simulate a shot, you first need to create a _system_, which contains a _cue_, a collection of _balls_, and a _table_.

```python
import pooltool as pt

# We're playing 9-ball
GAMETYPE = pt.GameType.NINEBALL

# Create necessary objects
cue = pt.Cue.default()
table = pt.Table.from_game_type(GAMETYPE)
balls = pt.get_rack(GAMETYPE, table)

# Package them into a System
system = pt.System(cue=cue, table=table, balls=balls)

# Visualize the system
gui = pt.ShotViewer()
gui.show(system)
```

[![system1]({{images}}/system1.jpg){:.no-border}]({{images}}/simple1.jpg){:.center-img .width-90}
_**Figure 1**. An untouched 9-ball system._

Since the system hasn't been simulated, there is no movement, just a static scene.

### Actions

To evolve the system, we first need to take an action. In pool, the only influence the player has on the table is how they contact the cue ball with the cue stick. In pooltool, there are 5 parameters that govern the cue stick's state upon impact:

- $V_0$: The speed the cue tip is moving at when the cue ball is contacted
- $\phi$: The direction that you are aiming relative to the table, between $0^{\circ}$ and $360^{\circ}$ degrees. For reference, $90^{\circ}$ aims up table.
- $\theta$: The elevation in degrees that the cue strikes the ball. $0^{\circ}$ corresponds to a cue stick parallel with the table surface
- $a$: The amount of side spin, between -1 and 1. Negative refers to right spin, positive refers to right spin.
- $b$: The amount of top/back spin, between -1 and 1. Negative refers to back spin, positive refers to top spin.


Wrap these up in a vector, $A = \langle V_0, \phi, \theta, a, b \rangle$, and that's all you need. This action vector $A$ dictates the evolution of the system. Let's extend the script to set the cue state and then evolve the system:

```diff
import pooltool as pt

# We're playing 9-ball
GAMETYPE = pt.GameType.NINEBALL

# Create necessary objects
cue = pt.Cue.default()
table = pt.Table.from_game_type(GAMETYPE)
balls = pt.get_rack(GAMETYPE, table)

# Package them into a System
system = pt.System(cue=cue, table=table, balls=balls)
+
+ # Take a shot
+ system.strike(V0=1.5, phi=90, theta=0, a=-0.5, b=0.2)
+ 
+ # Simulate it
+ pt.simulate(system, inplace=True)

# Visualize the system
gui = pt.ShotViewer()
gui.show(system)
```

[![system2]({{images}}/system2.gif){:.no-border}]({{images}}/simple2.jpg){:.center-img .width-90}
_**Figure 1**. A simulated 9-ball system._

### Rulesets

The above shot was illegal, but how do we determine that in pooltool? The answer is `Rulesets`. There is one for each game mode supported: `NineBall`, `EightBall`, `ThreeCushion`, and `Snooker`. Rulesets hold information about whose turn it is, what shot number it is, as well as the ability to process any shot and determine whether it was legal, whether the player's turn is over, etc.

We can get vital game information out of this game object by processing evolved systems. Let's extend the script again to do that:

```diff
import pooltool as pt

# We're playing 9-ball
GAMETYPE = pt.GameType.NINEBALL
+ 
+ # Create a game with 2 players
+ players = [pt.Player("Jon"), pt.Player("Joe")]
+ game = pt.NineBall(players)

# Create necessary objects
cue = pt.Cue.default()
table = pt.Table.from_game_type(GAMETYPE)
balls = pt.get_rack(GAMETYPE, table)

# Package them into a System
system = pt.System(cue=cue, table=table, balls=balls)

# Take a shot
system.strike(V0=1.5, phi=90, theta=0, a=-0.5, b=0.2)

# Simulate it
pt.simulate(system, inplace=True)
+ 
+ # Process the shot and print out whether the shot was legal
+ game.process_shot(system)
+ print(f"{game.shot_info.legal=}")
+ print(f"{game.shot_info.reason=}")

# Visualize the system
gui = pt.ShotViewer()
gui.show(system)
```

As we saw, the shot is definitely not legal and the game object agrees:

```python
game.shot_info.legal=False
game.shot_info.reason='4 rails must be contacted, or 1 ball potted'
```

### Multisystems

A system represents a single shot, but a game is composed of a collection of sequentially played shots, where the end state of one shot represents the start state of the next shot. We can represent this with a `Multisystem` object, which holds many systems.

Let's extend the script to play a complete game of 9-ball, which ends when the game has a winner (or when 40 shots have been taken).

```python
import pooltool as pt

# We're playing 9-ball
GAMETYPE = pt.GameType.NINEBALL

# Create a game with 2 players
players = [pt.Player("Jon"), pt.Player("Joe")]
game = pt.NineBall(players)

# Create necessary objects
cue = pt.Cue.default()
table = pt.Table.from_game_type(GAMETYPE)
balls = pt.get_rack(GAMETYPE, table)

# Package them into a System
system = pt.System(cue=cue, table=table, balls=balls)

# Create an empty multisystem
multisystem = pt.MultiSystem()

while True:
    # Take a shot
    system.strike(V0=1.5, phi=90, theta=0, a=-0.5, b=0.2)

    # Simulate it
    pt.simulate(system, inplace=True)

    # Process the shot
    game.process_shot(system)

    # Advance the shot
    game.advance(system)

    # Append to the multisystem
    multisystem.append(system)

    # Copy the system for the next shot
    system = system.copy()

    if game.shot_info.game_over or game.shot_number > 40:
        break

print(f"The winner is: {game.shot_info.winner}")

# Visualize the multisystem
gui = pt.ShotViewer()
gui.show(multisystem, title="Press [n] and [p] to cycle through different shots")
```

Since the cue parameters are the same for each shot, it is unsurprising that there is no winner:

```
The winner is: None
```

### Bot Framework

In the above example, we manually assigned an action to every shot:

```python
# Take a shot
system.strike(V0=1.5, phi=90, theta=0, a=-0.5, b=0.2)
```

But a bot should autonomously decide its own actions. Before starting this blog post, I'd actually done some work that allows one to easily incorporate bots into pooltool.

If you noticed, the `NineBall` class (and all `Ruleset` subclasses) accepts a list of `Player` objects:

```python
# Create a game with 2 players
players = [pt.Player("Jon"), pt.Player("Joe")]
game = pt.NineBall(players)
```

In anticipation of actually having a bot to use, I've extended the Player dataclass to support an AI attribute:

```python
@attrs.define
class Player:
    name: str
    ai: Optional[AIPlayer] = None

    @property
    def is_ai(self) -> bool:
        return self.ai is not None
```

So if you set the `ai` attribute for a player, you have an autonomous bot. Just like that.

The type of `ai` is `AIPlayer`, which isn't itself a concrete class, it's just a prototype with the following structure:

```python
class AIPlayer(Protocol):
    def decide(
        self,
        system: System,
        game: Ruleset,
        callback: Optional[Callable[[Action], None]] = None,
    ) -> Action:
        ...

    def apply(self, system: System, action: Action) -> None:
        ...
```

What this means is that in order to make a bot, you have to create a class which possesses two methods, `decide` and `apply`.

`decide` will, given the current system state and game state, return an action to take. And `apply`, when passed the system state and an action to take, will update cue parameters with the given action.

Let's create the world's worst bot (AKA Bot 0) that satisfies the contract defined by the `AIPlayer` protocol.

```python
from typing import Callable, Optional

import numpy as np
from pooltool.ai.action import Action
from pooltool.game.ruleset.datatypes import Ruleset
from pooltool.system.datatypes import System

class WorstAI:
    def decide(
        self,
        system: System,
        game: Ruleset,
        callback: Optional[Callable[[Action], None]] = None,
    ) -> Action:
        return Action(
            V0=np.random.uniform(0.5, 4),
            phi=np.random.uniform(0, 360),
            theta=np.random.uniform(0, 0),
            a=np.random.uniform(-0.5, 0.5),
            b=np.random.uniform(-0.5, 0.5),
        )

    def apply(self, system: System, action: Action) -> None:
        action.apply(system.cue)
```

As you can see, `WorstAI` simply returns cue parameters from a random uniform distribution.

I carved out a package in pooltool where I'm going to place all my bots, and placed `WorstAI` within it in its own directory `pooltool.ai.bot.worst`.

Let's add this AI to our script. First, import `WorstAI`:

```diff
+ from pooltool.ai.bot import WorstAI
```

Set each player's `ai` attribute to instances of `WorstAI`.

```diff
- players = [pt.Player("Jon"), pt.Player("Joe")]
+ players = [pt.Player("Jon", ai=WorstAI()), pt.Player("Joe", ai=WorstAI())]
```

And finally, delegate the responsibility of taking an action to the player, rather than passing hardcoded values to `system.strike`.

```diff
- system.strike(V0=1.5, phi=90, theta=0, a=-0.5, b=0.2)
+ player = game.active_player
+ action = player.ai.decide(system, game)
+ player.ai.apply(system, action)
```

Applying the changes, we have a script that pits two AI agents against one another in a game of 9-ball and reports the winner (or if 200 shots are reached, whichever happens first):

```python
import pooltool as pt
from pooltool.ai.bot import WorstAI

# We're playing 9-ball
GAMETYPE = pt.GameType.NINEBALL

# Create a game with 2 players
players = [pt.Player("Jon", ai=WorstAI()), pt.Player("Joe", ai=WorstAI())]
game = pt.NineBall(players)

# Create necessary objects
cue = pt.Cue.default()
table = pt.Table.from_game_type(GAMETYPE)
balls = pt.get_rack(GAMETYPE, table)

# Package them into a System
system = pt.System(cue=cue, table=table, balls=balls)

# Create an empty multisystem
multisystem = pt.MultiSystem()

while True:
    # Take a shot
    if player.is_ai:
        player = game.active_player
        action = player.ai.decide(system, game)
        game.active_player.ai.decide()

    system.strike(V0=1.5, phi=90, theta=0, a=-0.5, b=0.2)

    # Simulate it
    pt.simulate(system, inplace=True)

    # Process the shot
    game.process_shot(system)

    # Advance the shot
    game.advance(system)

    # Append to the multisystem
    multisystem.append(system)

    # Copy the system for the next shot
    system = system.copy()

    if game.shot_info.game_over or game.shot_number > 200:
        break

print(f"The winner is: {game.shot_info.winner}, after {game.shot_info.shot_number} shots")

# Visualize the system
gui = pt.ShotViewer()
gui.show(multisystem, title="Press [n] and [p] to cycle through different shots")
```

Running this script a handful of times yields the following outputs:

```bash
The winner is: Player(name='Jon', ai=<pooltool.ai.bot.worst.core.WorstAI object at 0x7f87b217a550>), after 99 shots
The winner is: Player(name='Joe', ai=<pooltool.ai.bot.worst.core.WorstAI object at 0x7fb18e2820a0>), after 106 shots
The winner is: Player(name='Joe', ai=<pooltool.ai.bot.worst.core.WorstAI object at 0x7fa5b617a0a0>), after 56 shots
The winner is: Player(name='Jon', ai=<pooltool.ai.bot.worst.core.WorstAI object at 0x7fde9497a550>), after 96 shots
The winner is: Player(name='Joe', ai=<pooltool.ai.bot.worst.core.WorstAI object at 0x7ff25997a0a0>), after 79 shots
```

`WorstAI` is appropriately named, because on average it takes Jon and Joe around 100 shots collectively to end the game. But it's served as a very important placeholder, because we now know how we can plug in more intelligent bots.

## Bot 1: Aim at the ball

`WorstAI` is bad for a lot of reasons, but what it lacks most is the capacity to aim at the lowest ball on the table. This inability leads to almost every shot being illegal.

Let's make another bot, `NaiveAimAI`, that aims at the lowest ball on the table with a 2-degree variation in $\phi$. It won't be aware of occluding balls that are between the cue and object ball, but this will no doubt out-perform the random model.

```python
from typing import Callable, Optional

import attrs
import numpy as np

import pooltool.ai.aim as aim
from pooltool.ai.action import Action
from pooltool.game.ruleset.datatypes import Ruleset
from pooltool.game.ruleset.utils import StateProbe, get_lowest_ball
from pooltool.system.datatypes import System


@attrs.define
class AimNaiveAI:
    def decide(
        self,
        system: System,
        game: Ruleset,
        callback: Optional[Callable[[Action], None]] = None,
    ) -> Action:
        action = Action(
            V0=np.random.uniform(0.5, 4),
            phi=np.random.uniform(0, 360),
            theta=np.random.uniform(0, 0),
            a=np.random.uniform(-0.5, 0.5),
            b=np.random.uniform(-0.5, 0.5),
        )

        lowest_ball = get_lowest_ball(system, when=StateProbe.CURRENT)
        action.phi = aim.at_ball(system, lowest_ball.id, cut=np.random.uniform(-70, 70))

        return action

    def apply(self, system: System, action: Action) -> None:
        action.apply(system.cue)
```

### Comparison to Bot 0

Let's give Jon this `AimNaiveAI` brain and see if he can beat Joe.

```diff
  players = [
-     pt.Player("Jon", ai=WorstAI()),
+     pt.Player("Jon", ai=AimNaiveAI()),
      pt.Player("Joe", ai=WorstAI()),
  ]
```

Out of 10 games, Jon won every one.

```
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
Winner: Player(name='Jon', ai=AimNaiveAI())
```

Since I'm going to do a lot of AI battles, it makes sense to invest time into developing some code where I can easily compare the performance metrics of various AIs. Inspired by the script we developed, I carved out a section in pooltool to accomplish that, and you can view it [here](https://github.com/ekiefl/pooltool/tree/7475907617bf8233869f850608c02030de1d3141/pooltool/ai/compete).

Now, I can generate awesome metric comparisons by running (from the pooltool root directory):

```bash
python pooltool/ai/compete/run.py
```

It produces the following plot:

[![worst_vs_naive]({{images}}/worst_vs_naive.png){:.no-border}]({{images}}/worst_vs_naive.png){:.center-img .width-90}
_**Figure 1**. A metric comparison between worst AI and second worst AI._

In a 20 game showdown, you can see that AimNaiveAI has a much higher legal hit rate, slightly higher average turn length, and consequently wins >90% of the games. Moving forward, I'm going to target high legal hit rates and high average turn lengths.

## Bot 2: Context-aware potting capabilities

In this iteration, I want to make a bot that can not only hit the lowest ball on the table, but can aim it into pockets. Furthermore, it should also be able to determine whether there are balls in the way of the cue ball's path, or the object ball's path.

Just a disclaimer here. If you're a pool junky, you're going to notice some incorrect assumptions I make, and that's because this is ultimately a **physics** problem, requiring an accurate quantification of many complex phenomena such as deflection of the cue ball when side spin is applied, swerve of the cue ball when the cuestick angle is not parallel with the playing surface, and cut- and spin-induced throw resulting from friction between the balls. And yet instead of treating it as such, I will ignore all of that and treat this as a **geometrical** problem, in part for simplicity and in part because many of these physical effects aren't yet incorporated into pooltool.

### Prior work

A while ago, github user [@edoson](github.com/edoson) reached out to me and we collaborated together to make a simple aiming procedure. The result was [this PR](https://github.com/ekiefl/pooltool/pull/55), which uses simple geometry to aim the cue ball at the object ball, such that the object ball is directed towards the pocket.

[![simple_pot1]({{images}}/simple_pot1.gif){:.no-border}]({{images}}/simple_pot1.gif){:.center-img .width-90}
_**Figure 1**. The aiming procedure in action._

To provide some autonomy to this aiming procedure, we included a function that calculates the best pocket to aim for, where "best" is approximated as the pot requiring the minimum "cut" angle.

Overall, the procedure is very simple, and **not without error**. For example, here you can see the aiming procedure chooses to shoot into the side pocket, even though it is not geometrically feasible:

[![simple_pot2]({{images}}/simple_pot2.gif){:.no-border}]({{images}}/simple_pot2.gif){:.center-img .width-90}
_**Figure 1**. The aiming procedure leaves much to be desired, where in this case, it erroneously thinks it decides the side pocket is best._

### A new aiming procedure

The above algorithm is ineffective because of the way it defines the point at which the object ball should move towards, which we termed the _potting point_. In a rather voodoo, way, this was our definition for the potting point:

[![simple_scheme1]({{images}}/simple_scheme1.jpg)]({{images}}/simple_scheme1.jpg){:.center-img .width-50}
_**Figure 1**. Possible potting point defined by the intersection of two perpendicular tangent lines of the pocket shelf's circular curvature._

Although problematically, this is a function of the pocket shelf's curvature. For example, if the radius of curvature is increased 3-fold, look where the aiming point lies:

[![simple_scheme2]({{images}}/simple_scheme2.jpg)]({{images}}/simple_scheme2.jpg){:.center-img .width-50}
_**Figure 1**. The potting point really should not be defined in relation to the pocket shelf's curvature, which can vary drastically and lead to completely unrealistic potting points_

So clearly this has to change. Next, I came up with the idea that the aiming point should be the point along the pocket shelf which protrudes furthest into the table:

[![simple_scheme3]({{images}}/simple_scheme3.jpg)]({{images}}/simple_scheme3.jpg){:.center-img .width-50}
_**Figure 1**. Possible potting point defined by the point along the pock shelf that protrudes furthest into the table._

This is _also_ problematic because if the pocket is nestled deep in the pocket jaws, you end up hitting the cushion before the pocket when you aim at this point:

[![simple_scheme4]({{images}}/simple_scheme4.jpg)]({{images}}/simple_scheme4.jpg){:.center-img .width-50}
_**Figure 1**. It hits the rail for God's sake!._

The problem with both of these approaches is that they are defined in relation to the pocket hole, where what really matters, is the cushion geometry that surrounds the pocket. That's why in the last case, the object ball hit the cushion rather than going in the pocket. And relatedly, where one aims typically depends on the angle that the object ball is entering the pocket from.

With that in mind, consider a new definition of the potting point defined by first calculating the intersection of the cushions adjacent to the pocket:

[![advanced_scheme1]({{images}}/advanced_scheme1.jpg)]({{images}}/advanced_scheme1.jpg){:.center-img .width-50}
_**Figure 1**. A new and improved potting point definition, where when the ball faces the pocket fully, the potting point is the the intersection of the adjacent cushions._

Above is the special case when the ball fully faces the pocket. In this case, we define the potting point as the intersection of the adjacent cushions. By removing our dependence on the pocket geometry itself, and instead focusing on the opening of the pocket, we remove complications arising from how far back the pocket lies, and shoddy dependencies on the shelf curvature.

Now let's consider another special case (the extremum case), where the ball is positioned along the rail:

[![advanced_scheme2]({{images}}/advanced_scheme2.jpg)]({{images}}/advanced_scheme2.jpg){:.center-img .width-50}
_**Figure 1**. In the extremum case where the ball is along the rail, the potting point is offset by one radius perpendicular to the adjacent cushion intersection._

Hopefully it's clear that it makes most sense to aim for one ball radius left (in this configuration) of the adjacent cushion intersection.

Great, so we know what to do in both these cases. Let's call the first case (when the ball faces the pocket entirely) **an angle of 0 degrees**, and the second case (when the ball hugs one rail) **an angle of 45 degrees**.

What do we do inbetween these two extrema? Well, it should clearly involve an offset that is more than 0 and less than the ball radius:

[![advanced_scheme3]({{images}}/advanced_scheme3.jpg)]({{images}}/advanced_scheme3.jpg){:.center-img .width-50}
_**Figure 1**. When the pot angle is betweeen 0 and 45 degreees, the offset from the adjacent cushion intersection is somewhere in between 0 and R (the ball radius)._

I'm not so concerned with deriving the most geometrically correct function that governs how the offset from the adjacent cushion intersection varies as a function of angle (which may or may not involve a sinusoidal!), so I'm just going to keep it simple and use a linear function.

To be clear, this aiming procedure isn't bullet proof, and shooting a ball at the potting point will not always guarantee a pot. As I've said already, a proper treatment would be grounded in physics. But it's an extensive improvement on the prior aiming procedure, and Rome wasn't built in a day. So let's implement it and move on to more exciting stuff.

### Implementing new procedure

With this theory-crafting done, it's time to improve the potting point logic with pooltool.

First, we need to associate to each pocket, the cushion segments that surround it. We'll make a small dataclass and dictionary mapping to do that:

```python
@attrs.define(frozen=True)
class Jaw:
    """Jaw IDs for a pocket

    Left and right are defined relative to the shooter
    """

    left_edge: str
    left_rail: str
    right_edge: str
    right_rail: str
    corner: bool


pocket_jaw_map: Dict[str, Jaw] = {
    "lb": Jaw("1", "18", "2", "3", True),
    "lc": Jaw("4", "3", "5", "6", False),
    "lt": Jaw("7", "6", "8", "9", True),
    "rb": Jaw("16", "15", "17", "18", True),
    "rc": Jaw("13", "12", "14", "15", False),
    "rt": Jaw("10", "9", "11", "12", True),
}
```

Pocket IDs are "left-bottom", "left-center", "left-top", etc., and the cushion segment IDs are from [this cushion diagram](https://ekiefl.github.io/2020/12/20/pooltool-alg/#ball-cushion-collision-times).

Here's what the final function looks like:

```python
def potting_point_corner(ball: Ball, table: Table, pocket: Pocket) -> Coordinate:
    jaw = pocket_jaw_map[pocket.id]
    lrail = table.cushion_segments.linear[jaw.left_rail]
    rrail = table.cushion_segments.linear[jaw.right_rail]

    # adjacent cushion intersection
    ACI = find_intersection_2D(
        l1x=lrail.lx,
        l1y=lrail.ly,
        l10=lrail.l0,
        l2x=rrail.lx,
        l2y=rrail.ly,
        l20=rrail.l0,
    )

    ball_to_ACI = ACI - ball.xyz[:2]

    lrail_unit = unit_vector_slow(lrail.p2 - lrail.p1)
    rrail_unit = unit_vector_slow(lrail.p2 - lrail.p1)

    # Point the cushion unit vectors towards the pocket
    if np.dot(ball_to_ACI, lrail_unit) < 0:
        lrail_unit *= -1
    if np.dot(ball_to_ACI, rrail_unit) < 0:
        rrail_unit *= -1

    theta_lrail = np.abs(angle_between_vectors(ball_to_ACI, lrail_unit))
    theta_rrail = np.abs(angle_between_vectors(ball_to_ACI, lrail_unit))

    assert theta_lrail <= 90.0
    assert theta_rrail <= 90.0

    # The rail with smallest theta is the rail ball is closest towards
    # Offset will be in opposite direction of other rail
    if theta_lrail < theta_rrail:
        theta = 45.0 - theta_lrail
        offset_dir = -rrail_unit
    else:
        theta = 45.0 - theta_rrail
        offset_dir = -lrail_unit

    assert 45.0 >= theta >= 0.0

    # Apply a sinusoidal interpolation, such that
    # theta = 0 -> 0
    # theta = 45 -> R
    offset_mag = np.sin(np.pi / 90 * theta) * ball.params.R
    return ACI + offset_dir * offset_mag
```

The full commit, which includes my treatment of the side pockets, is [here](https://github.com/ekiefl/pooltool/commit/3aaed5077c50127a3b41d70253c0e58d58f15be0).

The bot is able to pot most balls on the table now, even on this table with comically deep pockets:

[![advanced_example1]({{images}}/advanced_example1.gif){:.no-border}]({{images}}/advanced_example1.gif){:.center-img .width-90}
_**Figure 1**. Example 1 of the new aiming procedure._

[![advanced_example2]({{images}}/advanced_example2.gif){:.no-border}]({{images}}/advanced_example2.gif){:.center-img .width-90}
_**Figure 1**. Example 2 of the new aiming procedure._

[![advanced_example4]({{images}}/advanced_example4.gif){:.no-border}]({{images}}/advanced_example4.gif){:.center-img .width-90}
_**Figure 1**. Example 3 of the new aiming procedure._

There are also some issues though, which occur when the object ball is in the jaws of the pocket. When this happens, the cushion segments of the jaw can occlude the cue ball path to the calculated potting point:

[![advanced_example3]({{images}}/advanced_example3.gif){:.no-border}]({{images}}/advanced_example3.gif){:.center-img .width-90}
_**Figure 1**. Example 4 of the new aiming procedure. The cushion segments of the jaw can occlude the cue ball path to the calculated potting point._

To rememdy this, I added a subroutine that determines whether the ball is considered to be "in the jaws" of the pocket. And if the ball is in the jaws, the potting point becomes the center point of the pocket. Otherwise, the above routine is used.

So that's the idea. I calculated whether the ball is in jaws of the pocket by seeing whether its coordinates lie on the same side of a special line as the pocket center. If so, it's in the jaws. The line is drawn from the the left jaw tip to the right jaw tip. These tips are themselves calculated from the intersection between the left adjacent cushion and the left jaw edge, and the right adjacent cushion and the right jaw edge.

The ball goes in now:

[![advanced_example5]({{images}}/advanced_example5.gif){:.no-border}]({{images}}/advanced_example5.gif){:.center-img .width-90}
_**Figure 1**. The potting point changes when within the jaws of the pocket._

The code introduced by this change can be found [here](https://github.com/ekiefl/pooltool/commit/acee90af863b622e6733ba427e076256660d3710)

### Determine if pocket is viable

The "aiming procedure" developed above returns a potting angle, but this does not guarantee that the ball is pottable into a given pocket. Further steps are required to determine whether the pocket is even viable for a given ball, and there are several geometrical considerations that can make a shot unpottable.

I'll consider the following reasons for a ball being unpottable into a given pocket:

1. If the cut angle is too large
1. A ball/cushion occludes the straight line between the cue ball and where the cue ball must strike the object ball.
1. A ball/cushion occludes the straight line between the object ball and the potting point.
1. There isn't room to place a cue ball in contact with the object ball and behind the line of shot, due to a ball or cushion in the way

**Disclaimer**: you've got to walk before you run. I'm going to ignore advanced cue ball effects like swerve, which can allow one to masse around balls. I'm also going to ignore ball-ball friction, which can create outgoing object ball velocities that deviate from balls' line of centers. Finally, I'm going to ignore "cheating the pocket", where a ball may occlude the object ball's path to the calculated potting point, but the player still has sight of enough of the pocket to miss the occluding ball and still pot the ball.

A quick note about the cut angle being too large, and then I'll jump straight to the implementation: Sometimes the cut angle required for a pot is too great. Ignoring cue ball swerve and ball-ball friction, the maximum theoretical cut angle is bounded to be below 90 degrees, and this angle is only truly achievable when the distance from cue ball to object ball tends to infinity. As the distance between cue and object ball gets closer and closer, the max cut angle reduces more and more.

[![impossible1]({{images}}/impossible1.jpg){:.no-border}]({{images}}/impossible1.jpg){:.center-img .width-70}
_**Figure 1**. Here, the max cut angle is not enough to pot the object ball into the corner pocket. The max cut angle is ever so slightly less than 90 degrees, owing to the cue and object balls' radii. As the cue moves closer and closer towards the yellow ball (along their line of centers), the cut angle becomes less and less._

I created a number of functions, but ultimately, I think it's important that the AI has the following information available to it.

1. Which pockets are open to a given ball?
2. Which pockets are viable for potting a given ball?

Below are the corresponding functions, with explanations on terminology in their docstrings.

```python
def open_pockets(ball: Ball, table: Table, balls: Iterable[Ball]) -> Set[str]:
    """Return the IDs of pockets that are open to the ball

    An open pocket means that the ball has an unobscured path to the pocket, and that
    there is room to place a cue ball behind the object ball.

    See also: viable_pockets
    """
    return set(
        pocket.id
        for pocket in table.pockets.values()
        if not is_pocket_occluded(ball, table, pocket, balls)
        and is_room_for_cue_ball(ball, table, pocket, balls)
        and not is_jaw_in_way(ball, table, pocket)
    )


def viable_pockets(
    cue: Ball,
    ball: Ball,
    table: Table,
    balls: Iterable[Ball],
    max_cut: float = 80,
) -> List[Tuple[str, float]]:
    """Return viable pockets that the cue ball can sink the object ball into

    A viable pocket is one that is: 

        (1) Open
        (2) Max cut angle doesn't exceed max_cut. The theoretical max is 90
        (3) A straight line can be drawn between where the cue ball is and
            where the cue ball has to contact the object ball, without any
            obscuring balls or cushions.

    Returns:
        list of two-pules

    See also: open_pockets
    """

    viable = []
    for pocket in table.pockets.values():
        cut_angle = calc_cut_angle(
            cue.xyz[:2],
            ball.xyz[:2],
            get_potting_point(ball, table, pocket),
        )

        if (
            not is_pocket_occluded(ball, table, pocket, balls)
            and not is_object_ball_occluded(cue, ball, table, pocket, balls)
            and not is_jaw_in_way(ball, table, pocket)
            and np.abs(cut_angle) <= max_cut
        ):
            viable.append((pocket.id, cut_angle))

    return sorted(viable, key = lambda x: x[1])[::-1]
```

If you're interested in the finer details, the commit with all the changes is [here](https://github.com/ekiefl/pooltool/commit/693b2deb54e8fe0eacaaa892343838807714263a).

### Comparison with Bot 1

Now all that's left to do is make a class that satisfies the `AIPlayer` protocol, _i.e_ contains a `decide` and `apply` method, each with the correct call signature. Below is the implementation. It uses random cue parameters, except for $\phi$, which is calculated to pot the lowest ball into the "easiest" pocket, where easy is defined as the pocket requiring the smallest cut angle on the object ball.

```python
from typing import Callable, Optional

import attrs
import numpy as np

from pooltool.ai.action import Action
from pooltool.ai.pot import PottingConfig
from pooltool.game.datatypes import GameType
from pooltool.game.ruleset import get_ruleset
from pooltool.game.ruleset.datatypes import Ruleset
from pooltool.ptmath import wiggle
from pooltool.system.datatypes import System

AIMER = PottingConfig.default()

SUPPORTED_GAMETYPES = {
    GameType.NINEBALL,
}


@attrs.define
class AimPocketAI:
    game: Ruleset = attrs.field()
    dphi: float = attrs.field(default=0)

    @game.validator  # type: ignore
    def _game_supported(self, _, val) -> None:
        supports = [get_ruleset(gametype) for gametype in SUPPORTED_GAMETYPES]
        assert any(isinstance(val, cls) for cls in supports), f"{type(val)} unsupported"

    def decide(
        self,
        system: System,
        game: Ruleset,
        callback: Optional[Callable[[Action], None]] = None,
    ) -> Action:
        action = Action(
            V0=np.random.uniform(0.5, 4),
            phi=np.random.uniform(0, 360),
            theta=np.random.uniform(0, 0),
            a=np.random.uniform(-0.5, 0.5),
            b=np.random.uniform(-0.5, 0.5),
        )

        cue_ball = system.balls["cue"]
        object_ball = system.balls[game.shot_constraints.hittable[0]]

        pocket = AIMER.choose_pocket(cue_ball, object_ball, system.table, None)
        if pocket is None:
            # No pocket is viable, just pick any pocket :(
            pocket = list(system.table.pockets.values())[0]

        action.phi = AIMER.calculate_angle(
            cue_ball,
            object_ball,
            system.table,
            pocket,
        )

        action.phi = wiggle(action.phi, self.dphi)

        return action

    def apply(self, system: System, action: Action) -> None:
        action.apply(system.cue)
```

The full changes can be seen in [this commit](https://github.com/ekiefl/pooltool/commit/949318a32545a4b1b84def670a1f143a21b802e3).

In a 100 game match, our new bot blows `AimNaiveAI` out of the water. 

[![naive_vs_pot]({{images}}/naive_vs_pot.png){:.no-border}]({{images}}/naive_vs_pot.png){:.center-img .width-90}
_**Figure 1**. AimPocketAI outperforms AimNaiveAI, owing to the fact that it aims purposefully at pockets._

I also added a precison parameter, `dphi`, which simulates imperfect play by perturbing the calculated $\phi$ by $\pm dphi$ degrees. Look what happens when compete dphi=0.2 versus dphi=0.4. Keep in mind these are degrees, we are talking!

[![dphi_matters]({{images}}/dphi_matters.png){:.no-border}]({{images}}/dphi_matters.png){:.center-img .width-90}
_**Figure 1**. Despite 0.2 and 0.4 both being quite small angular perturbations, 0.2 performs significantly better against 0.4._

While it's obvious that higher precision is better, I personally found it surprising that such a small difference in precision (0.2 degrees) can create such a large difference in performance.

Finally, here's a movie between two `AimPocketAI` bots (with dphi=0) so you can get an idea of where we're at (sorry, but each shot plays in a loop, so I have to manually advance each shot, some unexpected shot replays):

{% include youtube_embed.html id="ilk3OAf94_M" %}

The bot is now decent at potting balls, although its worth noting that plays relentlessly aggressive, even when there are no viable pockets. Ideally it would play a _safety shot_, whereby it positions the cue ball such that the opponent has a tough shot. I'll try and address this later, but I would say there are currently even bigger fish to fry: planning the next shot.

## Bot 3: Reward-based flat search

A key component of 9-ball is potting the current lowest ball while simultaneously positioning the cue ball so that you can pot the next lowest ball. This is accomplished with _cue ball control_. Besides the direction that one hits the cue ball ($\phi$), one has control over how hard they hit, as well as the english (side spin, back spin, top spin) they apply to the cue ball, all of which have profound influence on the cue ball's final resting position.

Our current bot randomly decides these parameters, which means there is no planning for the next shot. With this iteration of bot development, I want to position the cue ball so the bot has a good look at the next ball. Since simulating outcomes is relatively quick, my strategy is to simulate a handful of shots with fixed $\phi$ but with all other action parameters randomized. Then, each shot can be graded using a heuristically-defined reward function, and the shot that yields the largest reward is chosen as the bot's shot.

To do this, we need to define what makes a shot "bad" and what makes a shot "good".

### Creating a reward function

