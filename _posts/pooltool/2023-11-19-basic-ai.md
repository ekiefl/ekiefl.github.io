---
layout: post
title: "Making a pool/billiards AI that outperforms humans"
categories: [pooltool]
excerpt: "I code and develop a heuristic-based AI from scratch that outperforms my abilities"
comments: true
series: 7
authors: [evan]
image:
  feature: pooltool/pooltool_banner.png
  display: true
---

{% capture images %}{{site.url}}/images/pooltool/pooltool-basic-ai{% endcapture %}

## Introduction

If you don't know, [pooltool](https://ekiefl.github.io/projects/pooltool/) is an open-source pool physics simulator that I've developed over the last 3 years.

[![pooltoolnow]({{ site.url }}/images/pooltool/pooltool-graphics/gallery_2.png)]({{ site.url }}/images/pooltool/pooltool-graphics/gallery_2.png){:.center-img .width-100}
_**Figure 1**. A screenshot of pooltool._

In this post, I'm going to take you on a journey for developing a 9-ball bot. My goal is to create something that outperforms humans, and incorporate it into the pooltool ecosystem so users have something to play against. I'm writing this as I go, so we'll see if that's possible!

## Aiming procedure

{:.notice}
To be clear, this is not AI yet! I'm just developing the toolkit of a future AI to be able to aim the cue ball at an object ball such that it goes into a pocket!

An AI must have the ability to aim the cue ball at an object ball, so as first step, I'm going to create an aiming procedure that can calculate what angle the object ball must be hit by the cue ball in order to be directed into a given pocket.

In reality, this is a **physics** problem, requiring an accurate quantification of many complex phenomena such as deflection of the cue ball when side spin is applied, swerve of the cue ball when the cuestick angle is not parallel with the playing surface, and cut- and spin-induced throw resulting from friction between the balls.

To start, I will ignore these phenomena and treat this as a **geometrical** problem, in part for simplicity and in part because many of these physical effects aren't yet incorporated into pooltool.

### Prior work

A while ago, github user [@edoson](github.com/edoson) reached out to me and we collaborated together to make a simple aiming procedure. The result was [this PR](https://github.com/ekiefl/pooltool/pull/55), which uses simple geometry to aim the cue ball at the object ball, such that the object ball is directed towards the pocket.

[![simple_pot1]({{images}}/simple_pot1.gif){:.no-border}]({{images}}/simple_pot1.gif){:.center-img .width-90}
_**Figure 2**. The aiming procedure in action._

To provide some autonomy to this aiming procedure, we included a function that calculates the best pocket to aim for, where "best" is approximated as the pot requiring the minimum "cut" angle.

Overall, the procedure is very simple, and **not without error**. For example, here you can see the aiming procedure chooses to shoot into the side pocket, even though it is not geometrically feasible:

[![simple_pot2]({{images}}/simple_pot2.gif){:.no-border}]({{images}}/simple_pot2.gif){:.center-img .width-90}
_**Figure 3**. The aiming procedure leaves much to be desired, where in this case, it erroneously thinks it decides the side pocket is best._

### Explanation of concept

The above algorithm is ineffective because of the way it defines the point at which the object ball should move towards, which we termed the _potting point_. In a rather voodoo, way, this was our definition for the potting point:

[![simple_scheme1]({{images}}/simple_scheme1.jpg)]({{images}}/simple_scheme1.jpg){:.center-img .width-50}
_**Figure 4**. Possible potting point defined by the intersection of two perpendicular tangent lines of the pocket shelf's circular curvature._

Though problematically, this is a function of the pocket shelf's curvature. For example, if the radius of curvature is increased 3-fold, look where the aiming point lies:

[![simple_scheme2]({{images}}/simple_scheme2.jpg)]({{images}}/simple_scheme2.jpg){:.center-img .width-50}
_**Figure 5**. The potting point really should not be defined in relation to the pocket shelf's curvature, which can vary drastically and lead to completely unrealistic potting points_

So clearly this has to change. Next, I came up with the idea that the aiming point should be the point along the pocket shelf which protrudes furthest into the table:

[![simple_scheme3]({{images}}/simple_scheme3.jpg)]({{images}}/simple_scheme3.jpg){:.center-img .width-50}
_**Figure 6**. Possible potting point defined by the point along the pock shelf that protrudes furthest into the table._

This is _also_ problematic because if the pocket is nestled deep in the pocket jaws, you end up hitting the cushion before the pocket when you aim at this point:

[![simple_scheme4]({{images}}/simple_scheme4.jpg)]({{images}}/simple_scheme4.jpg){:.center-img .width-50}
_**Figure 7**. It hits the rail for God's sake!._

The problem with both of these approaches is that they are defined in relation to the pocket hole, where what really matters, is the cushion geometry that surrounds the pocket. That's why in the last case, the object ball hit the cushion rather than going in the pocket. And relatedly, where one aims typically depends on the angle that the object ball is entering the pocket from.

With that in mind, consider a new definition of the potting point defined by first calculating the intersection of the cushions adjacent to the pocket:

[![advanced_scheme1]({{images}}/advanced_scheme1.jpg)]({{images}}/advanced_scheme1.jpg){:.center-img .width-50}
_**Figure 8**. A new and improved potting point definition, where when the ball faces the pocket fully, the potting point is the the intersection of the adjacent cushions._

Above is the special case when the ball fully faces the pocket. In this case, we define the potting point as the intersection of the adjacent cushions. By removing our dependence on the pocket geometry itself, and instead focusing on the opening of the pocket, we remove complications arising from how far back the pocket lies, and shoddy dependencies on the shelf curvature.

Now let's consider another special case (the extremum case), where the ball is positioned along the rail:

[![advanced_scheme2]({{images}}/advanced_scheme2.jpg)]({{images}}/advanced_scheme2.jpg){:.center-img .width-50}
_**Figure 9**. In the extremum case where the ball is along the rail, the potting point is offset by one radius perpendicular to the adjacent cushion intersection._

Hopefully it's clear that it makes most sense to aim for one ball radius left (in this configuration) of the adjacent cushion intersection.

Great, so we know what to do in both these cases. Let's call the first case (when the ball faces the pocket entirely) **an angle of 0 degrees**, and the second case (when the ball hugs one rail) **an angle of 45 degrees**.

What do we do inbetween these two extrema? Well, it should clearly involve an offset that is more than 0 and less than the ball radius:

[![advanced_scheme3]({{images}}/advanced_scheme3.jpg)]({{images}}/advanced_scheme3.jpg){:.center-img .width-50}
_**Figure 10**. When the pot angle is betweeen 0 and 45 degreees, the offset from the adjacent cushion intersection is somewhere in between 0 and R (the ball radius)._

I'm not so concerned with deriving the most geometrically correct function that governs how the offset from the adjacent cushion intersection varies as a function of angle (which may or may not involve a sinusoidal!), so I'm just going to keep it simple and use a linear function.

To be clear, this aiming procedure isn't bullet proof, and shooting a ball at the potting point will not always guarantee a pot. As I've said already, a proper treatment would be grounded in physics. But it's an extensive improvement on the prior aiming procedure, and Rome wasn't built in a day. So let's implement it and move on to more exciting stuff.

### Implementation of new procedure

With this theory-crafting done, it's time to improve the potting point logic with pooltool.

First, we need to associate to each pocket, the cushion segments that surround it. We'll make a small dataclass and dictionary mapping to do that:

```python
@attrs.define(frozen=True)
class Jaw:
    """Jaw IDs for a pocket

    Left and right are defined relative to the shooter
    """

    left_edge: str
    left_rail: str
    right_edge: str
    right_rail: str
    corner: bool


pocket_jaw_map: Dict[str, Jaw] = {
    "lb": Jaw("1", "18", "2", "3", True),
    "lc": Jaw("4", "3", "5", "6", False),
    "lt": Jaw("7", "6", "8", "9", True),
    "rb": Jaw("16", "15", "17", "18", True),
    "rc": Jaw("13", "12", "14", "15", False),
    "rt": Jaw("10", "9", "11", "12", True),
}
```

Pocket IDs are "left-bottom", "left-center", "left-top", etc., and the cushion segment IDs are from [this cushion diagram](https://ekiefl.github.io/2020/12/20/pooltool-alg/#ball-cushion-collision-times).

Here's what the final function looks like:

```python
def potting_point_corner(ball: Ball, table: Table, pocket: Pocket) -> Coordinate:
    jaw = pocket_jaw_map[pocket.id]
    lrail = table.cushion_segments.linear[jaw.left_rail]
    rrail = table.cushion_segments.linear[jaw.right_rail]

    # adjacent cushion intersection
    ACI = find_intersection_2D(
        l1x=lrail.lx,
        l1y=lrail.ly,
        l10=lrail.l0,
        l2x=rrail.lx,
        l2y=rrail.ly,
        l20=rrail.l0,
    )

    ball_to_ACI = ACI - ball.xyz[:2]

    lrail_unit = unit_vector_slow(lrail.p2 - lrail.p1)
    rrail_unit = unit_vector_slow(lrail.p2 - lrail.p1)

    # Point the cushion unit vectors towards the pocket
    if np.dot(ball_to_ACI, lrail_unit) < 0:
        lrail_unit *= -1
    if np.dot(ball_to_ACI, rrail_unit) < 0:
        rrail_unit *= -1

    theta_lrail = np.abs(angle_between_vectors(ball_to_ACI, lrail_unit))
    theta_rrail = np.abs(angle_between_vectors(ball_to_ACI, lrail_unit))

    assert theta_lrail <= 90.0
    assert theta_rrail <= 90.0

    # The rail with smallest theta is the rail ball is closest towards
    # Offset will be in opposite direction of other rail
    if theta_lrail < theta_rrail:
        theta = 45.0 - theta_lrail
        offset_dir = -rrail_unit
    else:
        theta = 45.0 - theta_rrail
        offset_dir = -lrail_unit

    assert 45.0 >= theta >= 0.0

    # Apply a sinusoidal interpolation, such that
    # theta = 0 -> 0
    # theta = 45 -> R
    offset_mag = np.sin(np.pi / 90 * theta) * ball.params.R
    return ACI + offset_dir * offset_mag
```

The full commit, which includes my treatment of the side pockets, is [here](https://github.com/ekiefl/pooltool/commit/3aaed5077c50127a3b41d70253c0e58d58f15be0).

The bot is able to pot most balls on the table now, even on this table with comically deep pockets:

[![advanced_example1]({{images}}/advanced_example1.gif){:.no-border}]({{images}}/advanced_example1.gif){:.center-img .width-90}
_**Figure 11**. Example 1 of the new aiming procedure._

[![advanced_example2]({{images}}/advanced_example2.gif){:.no-border}]({{images}}/advanced_example2.gif){:.center-img .width-90}
_**Figure 12**. Example 2 of the new aiming procedure._

[![advanced_example4]({{images}}/advanced_example4.gif){:.no-border}]({{images}}/advanced_example4.gif){:.center-img .width-90}
_**Figure 13**. Example 3 of the new aiming procedure._

There are also some issues though, which occur when the object ball is in the jaws of the pocket. When this happens, the cushion segments of the jaw can occlude the cue ball path to the calculated potting point:

[![advanced_example3]({{images}}/advanced_example3.gif){:.no-border}]({{images}}/advanced_example3.gif){:.center-img .width-90}
_**Figure 14**. Example 4 of the new aiming procedure. The cushion segments of the jaw can occlude the cue ball path to the calculated potting point._

To rememdy this, I added a subroutine that determines whether the ball is considered to be "in the jaws" of the pocket. And if the ball is in the jaws, the potting point becomes the center point of the pocket. Otherwise, the above routine is used.

So that's the idea. I calculated whether the ball is in jaws of the pocket by seeing whether its coordinates lie on the same side of a special line as the pocket center. If so, it's in the jaws. The line is drawn from the the left jaw tip to the right jaw tip. These tips are themselves calculated from the intersection between the left adjacent cushion and the left jaw edge, and the right adjacent cushion and the right jaw edge.

The results look great:

[![advanced_example5]({{images}}/advanced_example5.gif){:.no-border}]({{images}}/advanced_example5.gif){:.center-img .width-90}
_**Figure 15**. The potting point changes when within the jaws of the pocket._

The code introduced by this change can be found [here](https://github.com/ekiefl/pooltool/commit/acee90af863b622e6733ba427e076256660d3710)
