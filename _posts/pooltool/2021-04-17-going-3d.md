---
layout: post
title: "Billiards simulator IV: from simulation to game"
categories: [pooltool]
excerpt: "Turning the simulator into an interactive, 3D game with panda3d"
comments: true
authors: [evan]
image:
  feature: pooltool/pooltool_banner.png
  display: true
---

{% capture images %}{{site.url}}/images/pooltool/pooltool-going-3d{% endcapture %}
{% include _toc.html %}

## Goal

In the [last]({{ site.url }}/2020/04/24/pooltool-start/) post I implemented a prototype of the simulator that uses an event-based shot evolution algorithm and includes some primitive physics for resolving ball-ball and ball-cushion collision events. Then I wrote up a small class that visualizes shots with `pygame`. After working on the aesthetics a bit, that now looks like this:

[![bye_pygame]({{images}}/bye_pygame.gif){:.no-border}]({{images}}/bye_pygame.gif){:.center-img .width-60}

{:.notice}
If you followed last post closely, as of the last post I hadn't implemented the [(Han, 2005)]({{ site.url }}/2020/04/24/pooltool-theory/#3-han-2005) physics model for ball-cushion interactions. That is no longer true, and the implementation is active in the above simulation.

I think you'd agree it looks alright. It almost looks like the beginnings of a 2D pool game you might have found on [addictinggames.com](https://web.archive.org/web/20050204011135/http://www.addictinggames.com/) back in '05.

But my plans are much more ambitious than visualizing shots on a pixel-art table. **My goal is to turn this simulation into an interactive, 3D game/tool**. That's what this post is all about.

## My credentials

I have never made a game before. Let's see how this goes.

## Game engine selection

If I was a game developer, I probably would have written this in C# or C++, using [Unity](https://unity.com/) or [Unreal Engine](https://www.unrealengine.com/en-US/) as my game engine. But I don't know C# or C++, so I decided I was going to use a 3D **game engine with Python support**.

It turns out, there is only 1 option that deserves consideration: **[panda3d](https://www.panda3d.org/)**. Fortunately, it's by no means a bad option. Originally developed by Disney, they used it to develop [ToonTown](https://www.youtube.com/watch?v=-CEX1DLK5WU) (among a few other titles), and then later open-sourced it in a collaboration with Carnegie Mellon University for the purposes of using it as an educational tool.

Today, panda3d is a fully-featured, open-source game engine that remains under active development. It has good documentation and a relatively small, yet charitable and welcoming community. I must say, I feel a small sense of home every time I visit the [Discourse](https://discourse.panda3d.org/c/general-discussion) and in general, I've had a wonderful time using panda3d so far.

## Disclaimer: non-linear development

Throughout this post I present linear path of my progress, however it's not how things happened in reality. In my first iteration of development I focused solely on visualizing shots in 3D. This meant ignoring camera systems, user controls, menus, user actions and focusing entirely on the aesthetics like UV textures, shadows, animation sequences, etc. In other words, I was infatuated with creating a more and more aesthetically pleasing visualization.

But by adding more and more premature complexity, the integrity of my code was degrading. How was I going to implement the core design around this visualization? Yet I continued to push forward, steadfast and hungry for unnecessary frills like dynamic lighting and fancy animation effects. This continued until a tipping point was reached. I was trying to add translucent ghost balls that trail behind moving balls and ended up creating this:

{% include youtube_embed.html id="D6AJUyYeCiA" %}

This acid trip was a serious wake up call: I had focused so much on aesthetics that I had dug myself a grave, to which there was no getting out. There was no way I could have plugged this into an interactive framework--at least not with my self-worth intact.

So I scrapped it. I literally deleted the whole animation submodule and started from the ground up. I would still face many refactors and a complete rewrite of the core design, but this time my head was screwed on straight. This time, I decided I would establish a solid framework for user interactivity, within which shot visualization could be supported.

It's a classic example of "optimization is the root of all evil". Yet we are never safe from ourselves.

## Camera

Since the camera is how the user sees the game world, developing camera controls is quite literally the "hello world" of game design. Fortunately, 


