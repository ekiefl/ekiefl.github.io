---
layout: post
title: "Creating a billiards simulator II: Algorithm theory"
categories: [psim]
excerpt: "A dive into the algorithmic theory behind pool simulation"
comments: true
authors: [evan]
image:
  feature: psim/psim_banner.png
  display: true
---

{% capture images %}{{site.url}}/images/psim/psim-alg{% endcapture %}
{% include _toc.html %}

## What is a pool simulator?

In the [last post]({{ site.url }}/2020/04/24/psim-theory/) I discussed the physics for all the different phenomena in pool and
outlined equations of motion for each scenario. Yet there is still a critical missing piece: how and
when should these equations be applied? For instance, I have equations to resolve the collision
between two balls, but how do I know which two balls collided and when?

A pool simulator is more than just a sum of physics equations. Critically, a pool simulator requires
an algorithm that coordinates the proper usage of these equations, and glues them together to evolve
a shot from the moment the cue ball is struck to the moment the last ball stops moving. This
algorithm is what I call the **evolution algorithm**. The evolution algorithm advances the **system
state** from some initial time $t_i$, to some final time $t_f$.

In this post I define the system state, and then discuss two evolution algorithms: (1) discrete time
evolution, and (2) continuous event-based evolution.

## What is the system state?

In the [last post]({{ site.url }}/2020/04/24/psim-theory/) I defined the ball state by 3 vectors:
the ball's displacement $\vec{r}(t)$, velocity $\vec{v}(t)$, and angular velocity $\vec{\omega}(t)$.
Together, these three vectors fully characterize the state of a ball at any given time $t$. Since a
pool simulation has multiple balls, a state needs to be defined for the entire system, _i.e._ the
system state. Since the table is assumed to be fixed and unchanging, the system state for a given
time $t$ is just the collection of individual ball states at that time $t$.

<div class="extra-info" markdown="1">
<span class="extra-info-header">Definition: system state</span>

Mathematically, the ball state for the $i$th ball is

$$
s_i(t) = \{ \vec{r}_i(t) \, , \vec{v}_i(t), \, \vec{\omega}_i(t) \}
\notag
$$

where $\vec{r}_i(t)$ is the ball's position, $\vec{v}_i(t)$ is the ball's velocity, and
$\vec{\omega}_i(t)$ is the ball's angular velocity. The system state for a table with $N$ balls is
then

$$
S(t) = \{ s_i(t) \, \, \forall i \in \{1, ..., N\} \}
\notag
$$

where $t$ is some arbitrary time.

</div>

The evolution algorithm calculates the system system for a desired $t$ based on the system state at
an earlier time. With this definition formalized, let's move on to discuss the first evolution
algorithm: discrete time evolution.

## Discrete time evolution

The premise of discrete time evolution is to slowly advance the system state in very small
discrete steps of time. After each timestep events can be detected and resolved. Did a ball collide
with another ball, or with a cushion? If so, resolve the ball states, then advance to the next
system state. This is a really straight-forward evolution algorithm that is very convenient, and
simple to understand. Unfortunately, discrete time evolution introduces intrinsic error that reduces accuracy of when
events occur. An example is outlined in Figure 1.

[![discrete_error]({{images}}/discrete_error.jpg)]({{images}}/discrete_error.jpg){:.center-img .width-90}
_**Figure 1**. Collision detection using discrete time evolution. The collision is detected at the
timestep when the 2 balls overlap slightly._

In the above scenario, the blue ball gets incrementally closer to the red ball with each
timestep. After the third time step, the blue and red balls overlap slightly, triggering the detection
of a collision. Herein lies the fundamental problem with discrete time evolution: collision events
are never predicted, by rather detected _after_ they were already supposed to have happened.
So in the above example, the calculated collision time is $3 \Delta t$, even though the actual
collision time is less than that--more like $2.8 \Delta t$.

The inaccuracy introduced by discrete time evolution can always be ameliorated by making $\Delta
t$ smaller and smaller, yet there will always exist a margin of error on the order of $\Delta t$.
Furthermore, decreasing $\Delta t$ comes at massive computational cost. For example if you decrease
the timestep 100-fold--sure, you increase the accuracy 100-fold--but you also increase the
computational complexity 100-fold, since now you've gotta step through 100 times more time steps.

This can become brutal when dealing with pool simulations. Ball speeds commonly
reach $10$ m/s, and a reasonable requirement for realism is that 2 balls should never intersect more
than $1/100$th of a ball radius ($0.3$ mm). The required timestep for this level of realism is then
$30$ microseconds. If the time from the cue strike to the last ball rolling is 10 seconds, that is
$30,000$ time steps in total for one shot. If the level of realism is $1/1000$th a ball radius, that
is $300,000$ time steps. Yikes.

The problem with this is all of the wasted computation... I don't need $30$ microsecond time steps
when all of the balls are far apart and barely moving. It is only really in select scenarios, such
as a pool break, that realism demands such miniscule time steps. So a smart discrete time
evolution scheme would be to cut down on the number of time steps by making them
[adaptive](https://en.wikipedia.org/wiki/Adaptive_step_size) depending on the state of the system.
There are an infinite number of ways you could develop heuristics for an adaptive time stepper, that
may be based on the distances between balls (if they are far apart, increase the time step), or
based on velocities (if they are moving fast, decrease the time step). I'm not even going to go
there because the possibilities are endless, although I am convinced that if Virtual Pool 4 or
ShootersPool are using discrete time evolution, they are using adaptive time stepping.

<div class="extra-info" markdown="1">
<span class="extra-info-header">Aside: sometimes, you have to use discrete time evolution</span>

Discrete time evolution is sometimes a necessary evil in many-body systems when equations of
motion cannot be solved analytically. For example, the [three-body
problem](https://en.wikipedia.org/wiki/Three-body_problem) (3 planets exhibiting gravitational
forces on one another) has no analytical formulae that express the positions of the planets as a
function of time. That's because the system is just so complex:

[![3_body_problem]({{images}}/3_body_problem.gif)]({{images}}/3_body_problem.gif){:.center-img .width-90}
*Trajectories for three planetary bodies exhibiting gravitational forces on one another must be found through
discrete time evolution, since no analytical solutions exist. [Source](https://en.wikipedia.org/wiki/Three-body_problem)*

Fortunately, for any given state of the system, the _forces_ governing the equations are calculable
(inverse square law), and this is _all_ that is needed for discrete time evolution. If $\Delta t$
is chosen to be small enough, one can consider the force between the $i$th and $(i+1)$th time step
to be constant and since $\vec{F}=m\vec{a}$, that means acceleration is constant. We can discretely integrate
this equation once and then again to yield how the velocity and position should be updated for the $(i+1)$th timestep:

$$
\vec{a}_{i+1} = \vec{F}/m
\notag
$$

$$
\vec{v}_{i+1} = (\vec{F}/m) t + \vec{v}_i
\notag
$$

$$
\vec{r}_{i+1} = \frac{(\vec{F}/m)}{2}t^2 + \vec{v}_{i+1} t + \vec{r}_i
\notag
$$

</div>

## Continuous event-based evolution

{:.notice}
The continuous event-based evolution algorithm was first developed by Leckie and Greenspan in a
seminal paper entitled [An Event-Based Pool Physics
Simulator](https://link.springer.com/chapter/10.1007/11922155_19). If you would like to hear it
straight from the horse's mouth, a free pre-print of this publication is available
[here](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.89.4627&rep=rep1&type=pdf).

In the [last post]({{ site.url }}/2020/04/24/psim-theory/) I presented a bunch of analytical
equations of motion for ball trajectories, depending on whether the ball is [stationary]({{ site.url
}}/2020/04/24/psim-theory/#--case-1-stationary), [spinning]({{ site.url
}}/2020/04/24/psim-theory/#--case-2-spinning), [rolling]({{ site.url
}}/2020/04/24/psim-theory/#--case-3-rolling), [sliding]({{ site.url
}}/2020/04/24/psim-theory/#--case-4-sliding), or [airborne]({{ site.url
}}/2020/04/24/psim-theory/#section-iv-ball-air-interactions).

These equations are perfect, because we can use them to evolve the ball states to any arbitrary
time. The only (vital) problem is that **events** such as the collision in Figure 1 disrupt their
validity, since they are developed assuming the ball acts in isolation. For example, a ball
rolling with a very high velocity may be destined to travel 50m in an isolated environment, yet
collides with a cushion after just a few meters. Thus, the system can safely be evolved via [the
rolling equations of motion]({{ site.url }}/2020/04/24/psim-theory/#--case-3-rolling) **up until the
moment of collision**, at which point the event must be resolved via [the ball-cushion interaction
equations]({{ site.url }}/2020/04/24/psim-theory/#section-iii-ball-cushion-interactions). After the
collision is resolved, the system can be safely evolved up until the next event.

### (1) Algorithm description

This prescription of evolving the equations of motion up until the next event forms the basis of
the continuous event-based evolution algorithm. Simply stated, the algorithm goes like this:

<div class="extra-info" markdown="1">
<span class="extra-info-header">Continuous event-based evolution algorithm</span>

1. Set $t \rightarrow 0$.
2. Calculate the time $\Delta t_E$ until the next event. If $\Delta t_E = \infty$, stop.
3. Evolve the system state $S(t) \rightarrow S(t + \Delta t_E)$.
4. Resolve the event.
5. Set $t \rightarrow t + \Delta t_E$.
5. Repeat steps 2-5.

</div>

Let's walk through a loop of the algorithm. Assume the time is currently $t$, such that the system
state is $S(t)$.

The first step is determining when the next event occurs. By next event, I mean that **no other
event precedes it**. Assume this occcurs an amount of time $\Delta t_E$ from the current time.
Calculating $\Delta t_E$ is non-trivial, and my guess is that around 95% of the algorithm's
computational complexity is allocated to this specific task. The intricacies of this process will be
described _ad nauseam_ in the next section, but until then, assume $\Delta t_E$ is calculable.

Once calculated, the next step is to advance the system state from $S(t)$ to $S(t + \Delta t_E)$.
This means updating each ball's state to $s_i(t + \Delta t_E)$, where the equations of motion are
determined depending on whether the ball is stationary, spinning, rolling, sliding, or airborne.
Every ball is updated an amount $\Delta t_E$, independent of whether they are involved in the event
or not.

Then, the states of any balls involved in the event must be resolved. Some examples: If the event is
two balls colliding, their states are are resolved via [the ball-ball interaction equations]({{
site.url }}/2020/04/24/psim-theory/#section-ii-ball-ball-interactions). If the event is a ball
contacting a rail, its state is resolved via [the ball-cushion interaction equations]({{ site.url
}}/2020/04/24/psim-theory/#section-iii-ball-cushion-interactions). If the event is a ball transitioning
from sliding to rolling, its state is resolved by updating its equations of motions from
[sliding]({{ site.url }}/2020/04/24/psim-theory/#--case-4-sliding) to [rolling]({{ site.url
}}/2020/04/24/psim-theory/#--case-3-rolling).

Once the states of the balls involved in the event have been solved, every ball now has equations of
motion that will be valid until the next event occurs. Thus, the process repeats itself.

So that's how the algorithm works, and it is superior to the discrete time evolution algorithm
because one can advance directly to the next event. A typical shot may only have as little as 5
events, and calculating when they occur is orders of magnitude less computation than the hundreds of
thousands of time steps used in discrete time evolution for a typical shot. Not to mention the only
error in the continuous event-based evolution algorithm is due to floating point precision.

This is a beautifully simple algorithm, but its utterly useless if we can't calculate $\Delta t_E$,
the time until the next event--and that's no easy task. That's what I tackle in the next two
sections. First, I formally define what an event is and outline all possible events.
Then, in extruciating detail I outline how to calculate the time until the next event.

### (2) What are events?

In the context of the continuous event-based evolution algorithm, an event is defined as anything
that invalidates the equations of motion for 1 or more balls, due to something that is unaccounted
for in the equations of motion, such as a collision with another ball. In total, there are 7 events, 3 of
which are collisions, 4 of which are transitions. I discuss each below.

#### --- ball-ball collision

Unlike every other event, the ball-ball collision involves 2 balls, one of which must be in a
translating motion state: rolling, sliding, or airborne. The other ball may be in any motion state:
stationary, spinning, rolling, sliding or airborne. The collision is governed by [the ball-ball
interaction equations]({{ site.url }}/2020/04/24/psim-theory/#section-ii-ball-ball-interactions).

{% assign network_path = images | append: '/ball_ball_network.json' %}
{% include _network.html path=network_path id="ball_ball_network" height=325 %}

_Figure 2. The possible inputs and outputs of the ball-ball collision event._

If the incoming motion state is not airborne, then neither will be the outgoing state. Conversely,
if the incoming motion state is airborne, so will be the outgoing motion state. In other words, a
table-bound ball cannot become airborne due to a ball-ball collision. I admit this might be
confusing if you consider what happens when an airborne ball collides with a ball on the table:

{% include youtube_embed.html id="iT8k4W7tvM8" %}

They both end up airborne. Since the line of centers between the two balls is directed _into_ the
table, the outgoing velocity of the table-bound ball has a component into the table, which initiates
a ball-slate collision.  Consequently, the table-bound ball (the 3-ball) becomes airborne. In the
continuous event-based algorithm I've developed, the ball becomes airborne due to the ball-slate
collision, not the ball-ball collision, which are separated by an infinitesimally small amount of
time. As a network, the totality of this process looks like this:

{% assign network_path = images | append: '/ball_ball_event_path.json' %}
{% include _network.html path=network_path id="ball_ball_event_path" height=400 %}

_Figure 3. Network representation of events and ball motion states for the ball-ball collision slow-mo video._

#### --- ball-cushion collision

The ball-cushion collision involves just one ball, which must be in a translating motion state:
rolling, sliding, or airborne. The output state is either sliding or airborne. The collision is
governed by [the ball-cushion interaction equations]({{ site.url
}}/2020/04/24/psim-theory/#section-iii-ball-cushion-interactions).

{% assign network_path = images | append: '/ball_cushion_network.json' %}
{% include _network.html path=network_path id="ball_cushion_network" height=325 %}

_Figure 4. The possible inputs and outputs of the ball-cushion collision event._

The only way to have an outgoing airborne motion state is if the incoming motion state is also
airborne. Just like in the ball-ball collision, you may find this confusing, since after a collision
with a cushion, you often see it airborne:

{% include youtube_embed.html id="bMdHxdEzSxM" %}

Yet just like as described in the ball-ball collision, the ball becomes airborne due to the
ball-slate collision, which occurs an infinitesimally small amount of time after the ball-cushion
collision in the following interaction network.

{% assign network_path = images | append: '/ball_cushion_event_path.json' %}
{% include _network.html path=network_path id="ball_cushion_event_path" height=400 %}

_Figure 5. Network representation of events and ball motion states for the ball-cushion slow-mo
video_

#### --- ball-slate collision

The ball-slate collision occurs when a ball contacts the table with a velocity component _into_ the
table ($-z-$direction). The collision is governed by [the ball-slate interaction equations]({{
site.url }}/2020/04/24/psim-theory/#section-iv-ball-slate-interactions). Stationary, spinning, and
rolling balls necessarily have 0 speed along the $z-$axis, so the only available input motion
states are sliding and airborne. Obviously, an airborne ball undergoes a ball-slate collision when
it contacts the table. Additionally, we've seen in Figures 3 and 5 that sliding balls can also have
non-zero velocities in the $z-$direction (caused by ball-ball and ball-cushion collisions that
immediately precede the ball-slate collision), and also undergo ball-slate collisions. The first
possible outgoing motion state of the ball-slate interaction is being airborne. The second possible
outgoing motion state is sliding, which occurs when the ball doesn't have enough velocity to become
airborne.

{% assign network_path = images | append: '/ball_slate_network.json' %}
{% include _network.html path=network_path id="ball_slate_network" height=275 %}

_Figure 6. The possible inputs and outputs of the ball-slate collision event._

#### --- transition events

In Figures 2-6, I've shown that collisions often induce motion state transitions, however in each of
those cases the transition is caused by the collision. Yet motion state transitions also occur
naturally:

{% include youtube_embed.html id="A9mweRTxGiw" %}

In this short clip, the ball transitions from spinning to stationary. This is considered an event,
because upon becoming stationary, the ball's equations of motion (spinning) become
invalid and need to be updated to the stationary equations of motion.

<div class="extra-info" markdown="1">
<span class="extra-info-header">Definition: transition event</span>

A _transition event_ is when a ball's motion state naturally transitions to another motion state,
without being catalyzed by a collision.

{% assign network_path = images | append: '/x_y_transition_network.json' %}
{% include _network.html path=network_path id="x_y_transition_network" height=275 %}
_Figure 7. A transition event network is very simple. X goes in and Y goes out._

</div>

Mathematically, there are $5^4 = 1024$ transitions, but only 4 occur naturally. Thus there are only 4
transition _events_:

1. spinning-stationary
2. rolling-stationary
3. rolling-spinning
4. sliding-rolling

Fundamentally, these transitions happen due to a loss of energy due to friction. So these
transitions are always from high energy to low energy.

I've actually omitted 2 very rare transition events. In theory, a ball can transition
from spinning to stationary if the perfect amount of backspin is applied. Same goes for sliding to
spinning. So technically, there are 2 more transition events:

5\. sliding-stationary (_very rare_)

6\. sliding-spinning (_very rare_)

Yet, there is 0 margin for error for these scenarios. In virtually all simulated cases, a ball will
exit the sliding state with non-zero speed (using 64-bit floats with SI units yields femptometer
$(10^{-15})$ per second precisions). For this reason, the sliding-stationary and sliding-spinning
transition events can in all practical senses be decomposed into 2 transition events separated by
some very small amount of time. For example, the sliding-stationary transition can be decomposed
into the sliding-rolling transition followed by a rolling-stationary transition.

{% assign network_path = images | append: '/spinning_rolling_stationary_transition_network.json' %}
{% include _network.html path=network_path id="spinning_rolling_stationary_transition_network" height=275 %}

_Figure 8. The sliding-stationary transition event can be decomposed into the sliding-rolling
followed by the rolling-stationary transition events._

This wraps up my description of all possible events.

### (3) Calculating $\Delta t_E$

We now know all the possible events. So what's the strategy for calculating when the next
event occurs? Since there aren't that many balls, the strategy is to **calculate the time for _all_
possible events**. Then, the one that occurs in the shortest amount of time is by definition the
next event.

[![all_events]({{images}}/all_events.jpg)]({{images}}/all_events.jpg){:.center-img .width-100}
_**Figure 9**. A system with 1 sliding ball (A) and 2 stationary balls (B & C). The solid-filled
balls indicate where the balls currently are. There are 3  next events: (1) Ball A can
transition from sliding to rolling $(\Delta t^{(1)})$, (2) ball A can collide with ball B $(\Delta
t^{(2)})$, or (3) ball A can collide with ball C $(\Delta t^{(3)})$._

Consider the example pictured in Figure 9. Ball A is sliding, balls B & C are stationary, and there
are no other balls on the table. For simplicity, assume there are no cushions or pockets and that
the table surface extends indefinitely. To calculate the next event, we need to consider all
possible events. So let's do that.

- **ball-cushion collision events**. Since there are no cushions, there are no ball-cushion
  collision events to consider.
- **ball-slate collision events**. Balls B and C are stationary, so cannot undergo a ball-slate
  collision event. If ball A has a velocity component into the table, then the next event would be a
  ball-slate collision, since it would occur at $t=0$. But for the sake of example, let's assume
  ball A has no velocity component into the table. Then there are no ball-slate collision events to
  consider.
- **ball-ball collision events**. There are 3 potential ball-ball collision events:
  between balls A & B, A & C, and B & C. However, since 2 stationary balls cannot collide, the B & C
  collision is an impossible event, and only A & B, and A & C collisions need to be considered.
- **transition events**. Since balls B and C are stationary, there are no available transition
  events--they are already in their lowest energy states. On the other hand, Ball A is sliding, so a
  sliding-rolling transition event is a possibility for Ball A.

In summary, there are 3 events to consider: (1) a sliding-rolling transition for ball A, (2) a
ball-ball collision with balls A and B, and (3) a ball-ball collision with ball A and C. Based on
how I've drawn Figure 9, it's obvious that the next event is the sliding-rolling transition, yet in
general the time for each of these events must be calculated explicitly. If ball A was spinning a
lot, ball A could collide with ball B whilst spinning, which would make the collision with ball B
the next event. In fact, we can't even rule out that a collision with C is not the next event, which
could happen if ball A has a curved trajectory that goes around ball B.


So the point is this: given a system state $S(t)$, the only way to determine the next event $\Delta
t_E$, is to explicitly calculate the time of all possible next events. The next event is the one
that occurs in the smallest amount of time. In what follows, I gruesomely go through the algebra for
explicitly calculating collision and transition times.

#### --- Transition times

Transition times are the easiest to calculate, so I'll start with them.

The spinning-stationary transition is defined by the moment at which a spinning ball reaches 0
angular velocity in the $z-$direction. From the [spinning equations of motion]({{ site.url
}}/2020/04/24/psim-theory/#--case-2-spinning), the angular velocity as a function of time is given
by

$$ \omega_z(t) = \omega_{0z} - \frac{5\mu_{sp}g}{2R}t \notag $$

Setting this to 0 and solving for time yields the spinning-stationary transition time:

<div class="extra-info" markdown="1">
<span class="extra-info-header">Time until spinning-stationary transition event</span>

$$
\Delta t_E = \frac{2R}{5 \mu_{sp} g} \omega_{0z}
\label{spinning_stationary_time}
$$

where $\omega _{0z}$ is the current angular velocity in the $z-$direction.

</div>

Both the rolling-stationary events _and_ the rolling-spinning events are defined by the moment at
which a ball's center of mass velocity reaches 0. From the [rolling equations of motion]({{ site.url
}}/2020/04/24/psim-theory/#--case-3-rolling), the velocity of a rolling ball as a function of time
is given by

$$
\vec{v}(t) = \vec{v}_0 - \mu_r g t \hat{v}_0 \label{rolling_velocity}
\notag
$$

Taking the magnitude of both sides, setting the LHS to 0, and solving for time yields the
rolling-stationary and rolling-spinning transition times:

<div class="extra-info" markdown="1">
<span class="extra-info-header">Time until rolling-(stationary/spinning) transition events</span>

$$
\Delta t_E = \frac{v_0}{\mu_{r} g}
\label{rolling_spinning_stationary_time}
$$

where $v_0$ is the current ball speed.

If $\omega _{z}(\Delta t_E) = 0$, the event is a rolling-stationary transition event. Otherwise, it
is a rolling-spinning transition event.

</div>

The sliding-rolling transition is defined by the moment at which the relative velocity $\vec{u}$ becomes
$\vec{0}$. From the [sliding equations of motion]({{ site.url
}}/2020/04/24/psim-theory/#--case-4-sliding), the relative velocity as a function of time is given
by

$$
\vec{u}(t) = (u_0 - \frac{7}{2} \mu_s g t ) \, \hat{u}_0
\notag
$$

Taking the magnitude of both sides, setting the LHS to 0, and solving for time yields the
sliding-rolling transition time:

<div class="extra-info" markdown="1">
<span class="extra-info-header">Time until sliding-rolling transition event</span>

$$
\Delta t_E = \frac{2}{7} \frac{u_0}{\mu_s g}
\label{sliding_rolling_time}
$$

where $u_0$ is the current magnitude of the relative velocity.

</div>

That's all of the event transition times. Short and sweet.

#### --- Ball-ball collision times

Suppose the current time is $t$, and you want to calculate the time until collision, $\Delta t_E$,
between two balls with states $s^{(i)}(t)$ and $s^{(j)}(t)$. I'll call this the $i-j$ collision
event. Note that there is no reason these 2 balls must collide, so $\Delta t_E$ may well be
infinite. Within the time range $[t, t + \Delta t_E]$, I will assume neither of the balls are
involved in any other event. This means neither balls engage in any transitions or collisions. If
either did, then the intervening event necessarily precedes the $i-j$ collision event, which
means the $i-j$ collision event is no longer a candidate for being the next event.

**What is the collision condition?** The collision occurs when the distance between the center of
masses of the two balls is $2R$, where $R$ is the radii of the balls.

[![ball_ball_time]({{images}}/ball_ball_time.jpg)]({{images}}/ball_ball_time.jpg){:.center-img .width-90}
_**Figure 10**. The collision trajectory of the $i$th and $j$th balls. The magnitude of the distance
vector is $d _{ij}(t)$, and the collision occurs when $d _{ij}$ is $2R$._

Mathematically, we can
track the distance between the two balls as a function of time by defining a distance vector
$\vec{d}_{ij}(t)$:

$$
\vec{d}_{ij}(t) = \vec{r}^{(j)}(t) - \vec{r}^{(i)}(t)
\label{dist_vec_defn}
$$

where $\vec{r}^{(i)}(t)$ is the position of the $i$th ball and $\vec{r}^{(j)}(t)$ is the
position of the $j$th ball. The collision condition is thus

$$
\lvert \vec{d}_{ij}(\Delta t_E) \rvert = 2R
\label{collision}
$$

where $\Delta t_E$ is the collision time. The forms of $\vec{r}^{(i)}(t)$ and $\vec{r}^{(j)}(t)$ will depend on
the whether the balls are stationary, spinning, rolling, spinning, or airborne. Fortunately, we have
equations of motion for each of these scenarios, each of which can be cast in the following form:

$$
\vec{r}^{(i)}(t) = 
\begin{bmatrix}
    a_x^{(i)} t^2 + b_x^{(i)} t + c_x^{(i)} \\
    a_y^{(i)} t^2 + b_y^{(i)} t + c_y^{(i)} \\
    a_z^{(i)} t^2 + b_z^{(i)} t + c_z^{(i)}
\end{bmatrix}
\label{quad_r}
$$

As you can see, each component can be expressed as a quadratic equation with respect to time (though
in many cases the $a$, $b$, and $c$ coefficients are 0). The coefficients depend on which motion state the
ball is in. For example, Eq. $\eqref{quad_r}$ for a rolling ball has the following coefficients:

$$
a_x^{(i)} = - \frac{1}{2} \mu_r g \cos(\phi^{(i)})
\notag
$$

$$
a_y^{(i)} = - \frac{1}{2} \mu_r g \sin(\phi^{(i)})
\notag
$$

$$
a_z^{(i)} = 0
\notag
$$

$$
b_x^{(i)} = v_0^{(i)} \cos(\phi^{(i)})
\notag
$$

$$
b_y^{(i)} = v_0^{(i)} \sin(\phi^{(i)})
\notag
$$

$$
b_z^{(i)} = 0
\notag
$$

$$
c_x^{(i)} = r_{0x}^{(i)}
\notag
$$

$$
c_y^{(i)} = r_{0y}^{(i)}
\notag
$$

$$
c_z^{(i)} = 0
\notag
$$

which was determined by looking at the [the rolling equations of motion]({{ site.url
}}/2020/04/24/psim-theory/#--case-3-rolling). As another example, looking at
[the stationary equations of motion]({{ site.url }}/2020/04/24/psim-theory/#--case-1-stationary)
reveals that a stationary ball has the following coefficients in Eq. $\eqref{quad_r}$:

$$
a_x^{(j)} = a_y^{(j)} = a_z^{(j)} = 0
\notag
$$

$$
b_x^{(j)} = b_y^{(j)} = b_z^{(j)} = 0
\notag
$$

$$
c_x^{(j)} = r_{0x}^{(j)}
\notag
$$

$$
c_y^{(j)} = r_{0y}^{(j)}
\notag
$$

$$
c_z^{(j)} = 0
\notag
$$

Regardless of the particulars, the critical point is that a ball's trajectory is in a sense defined
by these 9 coefficients. To determine if two balls collide, we can formulate the distance vector
$\vec{d}(t)$ from Eq. $\eqref{dist_vec_defn}$ in terms of these 18 coefficients (2 balls, 9
coefficients each):

$$
\vec{d}_{ij}(t) = 
\begin{bmatrix}
    A_x t^2 + B_x t + C_x \\
    A_y t^2 + B_y t + C_y \\
    A_z t^2 + B_z t + C_z \\
\end{bmatrix}
\label{diff_vec}
$$

where

$$
A_x = a_x^{(j)} - a_x^{(i)}
\label{A_x_ball}
$$

$$
A_y = a_y^{(j)} - a_y^{(i)}
\label{A_y_ball}
$$

$$
A_z = a_z^{(j)} - a_z^{(i)}
\label{A_z_ball}
$$

$$
B_x = b_x^{(j)} - b_x^{(i)}
\label{B_x_ball}
$$

$$
B_y = b_y^{(j)} - b_y^{(i)}
\label{B_y_ball}
$$

$$
B_z = b_z^{(j)} - b_z^{(i)}
\label{B_z_ball}
$$

$$
C_x = c_x^{(j)} - c_x^{(i)}
\label{C_x_ball}
$$

$$
C_y = c_y^{(j)} - c_y^{(i)}
\label{C_y_ball}
$$

$$
C_z = c_z^{(j)} - c_z^{(i)}
\label{C_z_ball}
$$

Plugging Eq. $\eqref{diff_vec}$ into the collision condition Eq. $\eqref{collision}$ yields an
equation whose roots describe the time until two arbitrarily balls collide:

<div class="extra-info" markdown="1">
<span class="extra-info-header">Time until ball-ball collision event</span>

Let $\Delta t_E$ be the time until collision between the $i$th and $j$th balls.
$\Delta t_E$ is the smallest real and positive root to this polynomial equation:

$$
(A_x^2 + A_y^2 + A_z^2) \, \Delta t_E^4 + \\
(2 A_x B_x + 2 A_y B_y + 2 A_z B_z) \, \Delta t_E^3 + \\
(B_x^2 + B_y^2 + B_z^2 + 2 A_x C_x + 2 A_y C_y + 2 A_z C_z) \, \Delta t_E^2 + \\
(2 B_x C_x + 2 B_y C_y + 2 B_z C_z) \, \Delta t_E + \\
C_x^2 + C_y^2 + C_z^2 - 4 R^2 = 0
\label{ball_poly}
$$

where the coefficients are defined by Eqs. $\eqref{A_x_ball}$ - $\eqref{C_z_ball}$.

If there exists no real and positive root, then the balls do not collide.
</div>

Eq. $\eqref{ball_poly}$ can be solved analytically or numerically to reveal if/when the $i-j$
collision event occurs.

#### --- Ball-cushion collision times

This treatment is very similar to the ball-ball collision time calculation: develop an expression
for the distance between the ball and the cushion as a function of time--based off the quadratic
form of the ball's trajectory--and solve for the collision condition. Below, I present 2 treatments
for the ball-cushion time calculation.

The first is simpler, and defines the ball-cushion collision as the moment the ball contacts a
plane that extends vertically from the cushion's edge. I call this the _collision plane_.

[![arena]({{images}}/arena.jpg)]({{images}}/arena.jpg){:.center-img .width-90}

_**Figure 11**. Visualization of collision planes (orange) that extend vertically from the cushion
edges. Unlike how it's pictured, the planes are assumed to extend infinitely in the vertical
direction. A ball-cushion collision is assumed to occur whenever a ball contacts
a collision plane._

This assumption is convenient and mostly accurate when balls remain on or nearly on the table, but
creates false-positive collision events when balls in airborne motion motion states intersect the
collision plane. Even if balls remain on or nearly on the table, there is a slight inaccuracy
introduced that depends on how airborne the ball is, which is depicted in Figure 12. Neverthless,
convenience often outweights accuracy.

[![collision_plane_error]({{images}}/collision_plane_error.jpg)]({{images}}/collision_plane_error.jpg){:.center-img .width-50}

_**Figure 12**. A side view of the collision plane (orange). Two mock balls (red & blue) are
pictured at the moment they contact the cushion edge. As seen, there is a discrepancy between when
balls contact the collision plane versus the cushion edge._

**The collision condition** for a collision of the $i$th ball with the $j$th cushion occurs when the
$i$th ball contacts the $j$th cushion's collision plane. To define this condition mathematically, we
need to express the collision plane as an equation:

$$
l_x^{(j)} x + l_y^{(j)} y + l_0^{(j)} = 0
$$

This is just $y = mx + b$, where $m = -l_x^{(j)}/l_y^{(j)}$ and $b = -l_0^{(j)}/l_y^{(j)}$.
The shortest distance between a point $(p_x, p_y, p_z)$ and the plane
$l_x^{(j)} x + l_y^{(j)} y + l_0^{(j)} = 0$ is given by

$$
d = \frac{\lvert l_x^{(j)} p_x + l_y^{(j)} p_y + l_0^{(j)} \rvert}{\sqrt{l_x^{(j)\, 2} + l_y^{(j)\, 2}}}
\label{dist_to_plane}
$$

[(Source)](https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line). Rather than use an
arbitrary point $(p_x, p_y, p_z)$, here I throw in the trajectory of the $i$th ball from Eq.
$\eqref{quad_r}$:

$$
d_{ij}(t) = \frac{\lvert l_x^{(j)} r_x^{(i)}(t) + l_y^{(j)} r_y^{(i)}(t) + l_0^{(j)} \rvert}{\sqrt{l_x^{(j)\, 2} + l_y^{(j)\, 2}}}
\notag
$$

$$
d_{ij}(t) = \frac{\lvert l_x^{(j)} (a_x^{(i)} t^2 + b_x^{(i)} t + c_x^{(i)}) + l_y^{(j)} (a_y^{(i)} t^2 + b_y^{(i)} t + c_y^{(i)}) + l_0^{(j)} \rvert}{\sqrt{l_x^{(j)\, 2} + l_y^{(j)\, 2}}}
\notag
$$

where $d_{ij}$ is the distance between the $i$th ball and the $j$th cushion.

[![ball_cushion_time]({{images}}/ball_cushion_time.jpg)]({{images}}/ball_cushion_time.jpg){:.center-img .width-70}

_**Figure 13**. A top down view of a collision trajectory of the $i$th ball with the $j$th cushion.
The magnitude of the distance vector is $d _{ij}(t)$, and the collision occurs when $d _{ij}$ is
$R$--in other words when the ball contacts the collision plane (green line)._

With an expression that describes the distance between the $i$th ball and the $j$th cushion, I can
mathematically express the collision condition by setting $d_{ij}$ to $R$, which by definition
happens at a time $\Delta t_E$:

$$
\lvert l_x^{(j)} (a_x^{(i)} \Delta t_E^2 + b_x^{(i)} \Delta t_E + c_x^{(i)}) + l_y^{(j)} (a_y^{(i)} \Delta t_E^2 + b_y^{(i)} \Delta t_E + c_y^{(i)}) + l_0^{(j)} \rvert - \\
R\sqrt{l_x^{(j)\, 2} + l_y^{(j)\, 2}} = 0
\notag
$$

<div class="extra-info" markdown="1">
<span class="extra-info-header">Time until ball-cushion collision event (I)</span>

Let $\Delta t_E$ be the time until collision between the $i$th ball and $j$th cushion,
where the collision is detected via the collision plane.
$\Delta t_E$ is the smallest real and positive root to this polynomial equation:

$$
A \Delta t_E^2 + B \Delta t_E + C = 0
\label{cushion_poly_1}
$$

where

$$
A = l_x^{(j)} a_x^{(i)} + l_y^{(j)} a_y^{(i)}
\notag
$$

$$
B = l_x^{(j)} b_x^{(i)} + l_y^{(j)} b_y^{(i)}
\notag
$$

$$
C = l_0^{(j)} + l_x^{(j)} c_x^{(i)} + l_y^{(j)} c_y^{(i)} \pm R \sqrt{l_x^{(j)\, 2} + l_y^{(j)\, 2}}
\notag
$$

If no real positive root exists, the $i$th ball and $j$th cushion do not collide.

</div>

--------------------

As a more advanced treatment, I now consider a more physically accurate case in which the cushion is
treated as a line that coincides with the cushion's edge, depicted in orange in Figure 13.

[![cushion_line]({{images}}/cushion_line.jpg)]({{images}}/cushion_line.jpg){:.center-img .width-70}

_**Figure 13**. A ball in contact with a cushion. Mathematically, the ball-cushion collision is
detected by defining the cushion's edge, highlighted in orange._

Defining a collision line rather than a collision plane allows complete accuracy in determining
collision times (unlike the scenario in Figure 12), and permits balls to fly off the table, thereby
avoiding all false-positive ball-cushion collision events that occur with a collision plane.

The most convenient way to define the collision line of a cushion is to specify two points, where
the line connecting them is the collision line. The points for the collision line of the $j$th
cushion can be defined with the following vectors

$$
\vec{p}_1^{(j)} = \langle p_{1x}^{(j)}, \, p_{1y}^{(j)}, \, h \rangle
\notag
$$

$$
\vec{p}_2^{(j)} = \langle p_{2x}^{(j)}, \, p_{2y}^{(j)}, \, h \rangle
\notag
$$

where $h$ is the height of the rail. I assume here the rail height is constant, but it may be fun
exploring a relaxation of this assumption later. With these 2 vectors defined, the line can be parameterized via the
following vector:

$$
\vec{l}^{(j)} = 
\begin{bmatrix}
    p_{1x}^{(j)} + (p_{2x}^{(j)} - p_{1x}^{(j)}) \, s\\
    p_{1y}^{(j)} + (p_{2y}^{(j)} - p_{1y}^{(j)}) \, s\\
    h
\end{bmatrix}
\label{p1_vec}
$$

where $s$ determines where on the line you are. Just as the distance of a point to the
collision plane is given by Eq. $\eqref{dist_to_plane}$, we need an equation for the
distance of a point to the collision line. If such a point is described by the vector $\vec{p}_0 =
\langle p _{0x}, p _{0y}, p _{0z} \rangle$, then the minimum distance to the collision line is

$$
d = \frac{\lvert (\vec{p}_0 - \vec{p}_1^{(j)}) \times (\vec{p}_0 - \vec{p}_2^{(j)}) \rvert}
         {\lvert \vec{p}_2^{(j)} - \vec{p}_1^{(j)} \vert}
\notag
$$

[(Source)](https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html) where $\times$
denotes the cross product. By replacing $\vec{p}_0$ with the trajectory of the $i$th ball, we get
the distance of the $i$th ball to the $j$th cushion as a function of time.

$$
d_{ij}(t) = \frac{\lvert (\vec{r}^{(i)}(t) - \vec{p}_1^{(j)}) \times (\vec{r}^{(i)}(t) - \vec{p}_2^{(j)}) \rvert}
         {\lvert \vec{p}_2^{(j)} - \vec{p}_1^{(j)} \vert}
\label{dist_to_line}
$$

Like before, **the collision condition** is defined by setting $d_{ij}$ to $R$, which by definition
happens at time $\Delta t_E$. After substituting Eq. $\eqref{quad_r}$ into Eq.
$\eqref{dist_to_line}$, the algebra blows up.

[![ball_collision_line]({{images}}/ball_collision_line.png)]({{images}}/ball_collision_line.png){:.center-img .width-100}

{:.warning}
This page experiences a lot of lag if I try to render this math as an html object, so I took the
above screenshot instead. [Click here]({{images}}/ball_collision_line) for the html version.

It's beauty no doubt challenges that of Euler's $e^{i\pi} + 1 = 0$. Whether or not you agree doesn't
take away from the fact that this is a legitimate quartic polynomial with respect to time, the
roots of which describe the time until collision of ball $i$ and cushion $j$. The only thing that
needs to be done is grouping the different orders together so the solution can be presented.

<div class="extra-info" markdown="1">
<span class="extra-info-header">Time until ball-cushion collision event (II)</span>

Let $\Delta t_E$ be the time until collision between the $i$th ball and $j$th cushion, where the
collision is detected via the collision line. $\Delta t_E$ is the smallest real and positive root
to this polynomial equation:

$$
A \Delta t_E^4 + B \Delta t_E^3 + C \Delta t_E^2 + D \Delta t_E + E = 0
\label{cushion_poly_2}
$$

where $A$ is given by [this equation]({{images}}/A_collision_line), $B$ is given by [this equation]({{images}}/B_collision_line), $C$ is given by [this equation]({{images}}/C_collision_line), $D$ is given by [this equation]({{images}}/D_collision_line), and $E$ is given by [this equation]({{images}}/E_collision_line).

If no real positive root exists, the $i$th ball and $j$th cushion do not collide.

</div>

TODO

- replace line equation with 2 points
- outline solution for out of bounds solutions in line collision and plane collision





















